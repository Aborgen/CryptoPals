import pytest
import json
import initTest
from modules.breakThings.crack import _crackRepeatingXOR, _crackSingleXOR
from modules.utils.convert import b642bytes

@pytest.fixture
def frequentLetters():
  # Numbers from https://en.wikipedia.org/wiki/Letter_frequency
  rubric = {
    b"e": 0.12702,
    b"t": 0.9056,
    b"a": 0.8167,
    b"o": 0.7507,
    b"i": 0.6966,
    b"n": 0.6749,
    b"s": 0.6327,
    b"h": 0.6094,
    b"r": 0.5987,
    b"d": 0.4253,
    b"l": 0.4025,
    b"c": 0.2782,
    b"u": 0.2758,
    b"m": 0.2406,
    b"w": 0.2360,
    b"f": 0.2228,
    b"g": 0.2015,
    b"y": 0.1974,
    b"p": 0.1929,
    b"b": 0.1492,
    b"v": 0.0978,
    b"k": 0.0772,
    b"j": 0.0153,
    b"x": 0.0150,
    b"q": 0.0095,
    b"z": 0.0074
  }

  return rubric

class Test_crack_XOR():
  def test_crack_single_XOR(self, frequentLetters):
    ciphertext = bytes.fromhex("1b37373331363f78151b7f2b783431333d78397828372d363c78373e783a393b3736")
    expected   = b"Cooking MC's like a pound of bacon"
    key = b'X'

    candidate = _crackSingleXOR(ciphertext, frequentLetters)
    assert key == candidate.key[:1] and expected == candidate.secret
  # It seems that this algorithm requires a rather large amount
  # of text in order to be effective
  def test_crack_repeating_XOR(self, frequentLetters):
    ciphertext = b642bytes('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')
    expected = b642bytes('Q09GRkVFLCBvZiBsYXRlIFllYXJzLCBpcyBncm93biBzbyBtdWNoIGluIHJlcXVlc3QgdGhyb3VnaG91dCBfRW5nbGFuZF8sCl9Ib2xsYW5kXywgYW5kIG90aGVyIFBhcnRzIG9mIF9FdXJvcGVfLCB0aGF0IEkgbmVlZCBzYXkgbGl0dGxlIHRvCnJlY29tbWVuZCBpdHMgSGlzdG9yeSB0byB0aGUgV29ybGQ6IFRoZSBnZW5lcmFsIFVzZSBvZiBpdCByYXRoZXIgc2VlbXMKdG8gY29tbWFuZCB0aGlzIFdvcmssIHRoYXQgYnkgb3VyIGhhdmluZyBhIG1vcmUgZmFtaWxpYXIgS25vd2xlZGdlIG9mCml0LCB3ZSBtYXkgcmVsaXNoIGl0IHRoZSBiZXR0ZXIuIEFuZCBhZ2Fpbiwgd2hhdCB5ZXQgcHJvbXB0cyBtZSBmdXJ0aGVyCnRvIHRoaXMgVW5kZXJ0YWtpbmcsIGlzIHRoZSBPcHBvcnR1bml0eSBJIGhhdmUgYXQgdGhpcyB0aW1lIHRvIHByZXNlbnQKdGhlIFdvcmxkIHdpdGggYSBwZXJmZWN0IEZpZ3VyZSBvZiB0aGUgX1RyZWVfIHRoYXQgcHJvZHVjZXMgdGhpcwpjZWxlYnJhdGVkIF9GcnVpdF87IHdoaWNoIGlzIG5vdCBkb25lIGhlcmUgYnkgYW55IHJhbmRvbSBHdWVzcywgb3IKYWNjb3JkaW5nIHRvIHRoZSB1bmNlcnRhaW4gUmVwb3J0IG9mIG90aGVycywgYnV0IGRyYXduIGJ5IG15IG93biBIYW5kCmZyb20gYSBncm93aW5nIFRyZWUuCgpBTkQgdGhhdCBJIG1heSBvYnNlcnZlIHNvbWUgc29ydCBvZiBNZXRob2QgaW4gdGhlIFByb3NlY3V0aW9uIG9mIG15CkRpc2NvdXJzZSwgSSBzaGFsbCwgaW4gdGhlIGZpcnN0IHBsYWNlLCBnaXZlIG15IFJlYWRlciB0aGUgTmFtZXMgYW5kCkRlc2NyaXB0aW9ucyBvZiBpdCwgZnJvbSB0aGUgc2V2ZXJhbCBBdXRob3JzIHdobyBoYXZlIG1lbnRpb25lZCBpdDsgYW5kCnRoZW4gSSBzaGFsbCBvZmZlciBhIG1vcmUgZXhhY3QgQWNjb3VudCwgZnJvbSBteSBvd24gS25vd2xlZGdlLCBvZiB0aGUKX1BsYW50XywgX0Zsb3dlcl8sIGFuZCBfRnJ1aXRfLCBmb3IgdGhlIGJldHRlciB1bmRlcnN0YW5kaW5nIG9mIHRoZQphZm9yZXNhaWQgRmlndXJlOiBhZnRlciB3aGljaCwgSSBzaGFsbCBzZXQgZG93biB0aGUgVGltZSBhbmQgTWFubmVyIG9mCml0cyBmaXJzdCBBcHBlYXJhbmNlIGluIF9FbmdsYW5kXywgd2l0aCBpdHMgVmlydHVlcyBhbmQgVXNlcy4gVG8gd2hpY2ggSQpzaGFsbCBhZGQgc29tZSBuZWNlc3NhcnkgT2JzZXJ2YXRpb25zIHJlbGF0aW5nIHRvIHRoZSBPcmlnaW5hbCBQbGFjZSBvZgppdHMgR3Jvd3RoLCBhbmQgTWFubmVyIG9mIFRyYWRpbmcgZm9yIGl0OyBhbmQgY29uY2x1ZGUgd2l0aCBzb21lIFJlbWFya3MKSSBoYXZlIG1hZGUgb2YgaXRzIEN1bHR1cmUgaW4gdGhlIF9BbXN0ZXJkYW1fIEdhcmRlbi4KCl9KQUNPQiBDT1RPVklDVVNfLCBpbiBoaXMgVHJhdmVscyB0byBfSmVydXNhbGVtXywgX0Fubm8gMTU5OC5fIG1lbnRpb25zCnRoZSBfQ29mZmVlXyB0byBoYXZlIGJlZW4gYXQgdGhhdCB0aW1lIGEgRHJpbmsgbXVjaCBpbiB1c2UgYW1vbmdzdCB0aGUKX1R1cmtzXzsgYW5kIHRlbGxzIHVzLCB0aGF0IHNvbWUgb2YgdGhlIF9BcmFiaWFuc18gY2FsbGVkIGl0IF9DYWh1YV8sCmFuZCBvdGhlcnMgX0J1bm51XyBhbmQgX0J1bmNoaV8sIGJ1dCBnaXZlcyB1cyBubyBEZXNjcmlwdGlvbiBvZiB0aGUKUGxhbnQuIEhlIGlzIHRoZSBmaXJzdCBBdXRob3IgdGhhdCBJIGZpbmQgdG8gaGF2ZSBtZW50aW9uZWQgdGhpcyBMaXF1b3IuCgpfUFJPU1BFUiBBTFBJTlVTXywgYSBQaHlzaWNpYW4gb2YgX1ZlbmljZV8sIGluIGhpcyBCb29rIG9mIF9FZ3lwdGlhbgpQbGFudHNfLCBtYWtlcyBtZW50aW9uIG9mIHRoZSBfVHJlZV8sIGFuZCBnaXZlcyB1cyBhbiBpbXBlcmZlY3QgQ3V0IG9mCml0OiBIZSB0ZWxscyB1cywgdGhhdCBoZSBmaXJzdCBzYXcgaXQgaW4gYSBHYXJkZW4gYmVsb25naW5nIHRvIGEgQ2FwdGFpbgpvZiB0aGUgSmFuaXphcmllcyBhdCBfR3JhbmQgQ2Fpcm9fLCBicm91Z2h0IGZyb20gX0FyYWJpYSBGZWxpeF8sIGFuZApwbGFudGVkIHRoZXJlIGFzIGEgZ3JlYXQgUmFyaXR5OiBJdCBpcywgc2FpdGggaGUsIGxpa2UgdGhlIF9FdW9ueW11c18gb3IKX1ByaWNrbGUtVGltYmVyXywgYnV0IHdpdGggTGVhdmVzIHRoaWNrZXIsIGhhcmRlciwgYW5kIGdyZWVuZXIuIE9mIHRoZQpGcnVpdCAoY2FsbGVkIF9CdW5hXykgdGhlIF9UdXJrc18gYW5kIF9BcmFic18gbWFrZSBhIERlY29jdGlvbiBvciBEcmluaywKd2hpY2ggdGhleSB1c2UgaW5zdGVhZCBvZiBXaW5lLCBhbmQgaXMgY2FsbGVkIF9Db2F2YV8uCgpfUEFMVURBTVVTXywgYWZ0ZXIgaGltLCBtZW50aW9ucyBpdCBieSB0aGUgTmFtZSBvZiBfQ2hvYXZhXzsgYW5kCl9SYXV3b2xmaXVzXyBjYWxscyBpdCBfQ2hhdWJlXzsgYnV0IG5laXRoZXIgb2YgdGhlbSBkbyBtYWtlIGFueSBSZW1hcmtzCnVwb24gaXQsIHRoYXQgYXJlIHdvcnRoeSB0byBiZSBjb21tdW5pY2F0ZWQgdG8gbXkgUmVhZGVyOyBmb3IgdGhlc2UKQXV0aG9ycyB3cml0IG5lYXIgYSBodW5kcmVkIFllYXJzIHNpbmNlLCB3aGVuIF9Db2ZmZWVfIHdhcyBsaXR0bGUga25vd24KdG8gdGhlIF9FdXJvcGVhbnNfLgo=')
    key = b"The Virtue and Use of Coffee"
    candidate = _crackRepeatingXOR(ciphertext, frequentLetters, keySizeRange = (2, 40), blockNumber = 4)
    assert key == candidate.key and expected == candidate.secret
